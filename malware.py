import os
import sys
import platform
import time
import requests
import hashlib
import uuid
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from zipfile import ZipFile
import socket

from PyQt5.QtGui import QFont
from PyQt5.QtGui import QFontDatabase
from PyQt5.QtWidgets import QApplication

# List of file extensions to scan
SCAN_EXTENSIONS = [
    ".exe", ".dll", ".sys", ".doc", ".docx", ".xls", ".xlsx", ".py", ".xml", ".cfg", ".txt", ".ppt", ".pptx", ".hwp",
    ".com", ".scr", ".bat", ".cmd", ".jar", ".class", ".js", ".vbs", ".wsf", ".jse", ".wsc", ".wsh", ".msc", ".msi",
    ".cpl", ".msp", ".sct", ".ocx", ".cab", ".ax", ".dht", ".dotm", ".dotx"
]

# Directories to exclude from scanning
EXCLUDE_DIRS = ["venv", "venv2", ".idea", "lib"]

# Current date
_today_ = datetime.today().strftime("%Y-%m-%d")

# File paths
_engine_zipfile_ = f"{os.getcwd()}/{_today_}.zip"
_engine_extract_file_ = f"{os.getcwd()}/engine.db"
_scan_result_logs_ = f"{os.getcwd()}/output/{_today_}-infected.log"

folder_selected = None  

# Function to download the engine
def download_engine():
    # URL of the engine
    _url = "https://bazaar.abuse.ch/export/txt/sha256/full/"
    _header = {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/49.0.2623.112 Safari/537.36",
        "Connection": "keep-alive",
    }
    try:
        # Download the engine file
        with open(_engine_zipfile_, "wb") as f:
            r = requests.get(_url, headers=_header, stream=True)
            download_file_length = r.headers.get("Content-Length")

            if download_file_length is None:
                f.write(r.content)
            else:
                dl = 0
                total_length = int(download_file_length)
                start = time.perf_counter()
                for data in r.iter_content(chunk_size=8092):
                    dl += len(data)
                    f.write(data)

        # Extract the downloaded engine
        extract_gzip(_engine_zipfile_)

    except Exception as e:
        print(
            f'Error downloading engine: {e}'
        )
    finally:
        r.close()


# Function to extract the engine file
def extract_gzip(_engine_zipfile_):
    with ZipFile(_engine_zipfile_, "r") as zipObj:
        file_list = zipObj.infolist()
        for file in file_list:
            if file.filename[-1] == "/":
                continue
            file.filename = os.path.basename(file.filename)
            if file.filename.lower() == "full_sha256.txt".lower():
                zipObj.extract(file, os.getcwd())
                _update_file = f"{os.getcwd()}/{file.filename}"

                if os.path.isfile(_engine_extract_file_):
                    os.remove(_engine_extract_file_)

                try:
                    os.rename(_update_file, _engine_extract_file_)
                except OSError as e:
                    print(f"{_update_file} can not be renamed")
                    sys.exit(1)

    # Remove Engine zip
    try:
        os.remove(_engine_zipfile_)
    except OSError as e:
        print(f"{_update_file} can not be renamed")
        sys.exit(1)

    # Check Downloaded File
    if os.path.isfile(_engine_extract_file_):
        with open(_engine_extract_file_, "rb") as f:
            file_read = f.read()
            file_hash = hashlib.sha256(file_read).hexdigest()
            file_info = f'===> Extracted Size: {int(os.path.getsize(_engine_extract_file_)) / (1024.0 * 1024.0):.2f} MB\n===> Hash(SHA-256) : {file_hash}\n'

            print(f"\n\n===> Update Success: {_engine_extract_file_}")
            print(file_info)
    else:
        print(f"[-] {_engine_extract_file_} not found.")
        sys.exit(1)


# Function to check if hash exists in the database
def hash_exists_in_db(check_hash):
    if os.path.isfile(_engine_extract_file_):
        with open(_engine_extract_file_, "r") as database:
            for line in database:
                if len(line.strip()) != 0:
                    if not line.startswith("#"):
                        if str(check_hash) in str(line):
                            return True
    return False


# Function to log scan results
def scan_result_logs(_contents):
    _make_output_dir = f"{os.getcwd()}/output"
    _mode = "w"

    if os.path.exists(_make_output_dir):
        if os.path.exists(_scan_result_logs_):
            _mode = "a"
    else:
        _mode = "w"
        os.makedirs(_make_output_dir)

    with open(_scan_result_logs_, _mode) as fa:
        fa.write("%s" % _contents)


# Function to calculate hash of a file
def make_hash(_f_file_name):
    _file_hash = ""
    if os.path.isfile(_f_file_name):
        with open(_f_file_name, "rb") as f:
            filename_read = f.read()
            _file_hash = hashlib.sha256(filename_read).hexdigest()
    return _file_hash


# Function to check file extension
def check_file_extension(_file_name):
    if _file_name.endswith(tuple(SCAN_EXTENSIONS)):
        return True
    else:
        return False


# Function to check file size
def check_file_size(_f_file_name):
    _limit = 10485760  # 10MB

    f = os.stat(_f_file_name).st_size
    if f <= _limit:
        return True
    else:
        return False


# Function to create a unique job id
def create_job_id():
    return uuid.uuid4()


# Function to get file creation date
def get_create_date(_f_file_name):
    if platform.system() == "Windows":
        _result = os.path.getctime(_f_file_name)
    else:
        _result = os.path.getmtime(_f_file_name)
    return datetime.fromtimestamp(_result).strftime("%Y-%m-%d %H:%M:%S")


# Function to get file modification date
def get_modify_date(_f_file_name):
    _result = os.path.getmtime(_f_file_name)
    return datetime.fromtimestamp(_result).strftime("%Y-%m-%d %H:%M:%S")


# Function to get the IP address of the system
def get_ip_address():
    return socket.gethostbyname(socket.gethostname())


# Function to check the engine and update if necessary
def check_engine():
    if os.path.exists(_engine_extract_file_):
        modify_filetime = os.stat(_engine_extract_file_).st_mtime
        today_num_ymd = datetime.today().strftime("%Y%m%d")
        _engine_file_date = datetime.fromtimestamp(modify_filetime).strftime("%Y%m%d")

        if not (int(_engine_file_date) == int(today_num_ymd)):
            _get_download = False
        else:
            _get_download = True

        if not _get_download:
            print(f"Updating Engine Signatures.")
            download_engine()
        else:
            print(f"Engine is upto date")
    else:
        print(f"Updating Engine Signatures.")
        download_engine()

# Function to scan files for malware
def scan_file(file_path):
    # Initialize scan result
    scan_result = {
        'file_path': file_path,
        'hash_match': False,
        'string_match': False,
        'file_hash': None
    }

    # Check if file extension is in the list of extensions to scan
    if check_file_extension(file_path):
        # Check if file size is within limit
        if check_file_size(file_path):
            # Calculate hash of the file
            file_hash = make_hash(file_path)
            scan_result['file_hash'] = file_hash
            # Check if hash exists in the database
            if hash_exists_in_db(file_hash):
                scan_result['hash_match'] = True

            # Check if file content contains the EICAR test string
            with open(file_path, 'r') as file:
                content = file.read()
                if contains_eicar_test_string(content):
                    scan_result['string_match'] = True

    return scan_result


# Function to check if content contains the EICAR test string
def contains_eicar_test_string(content):
    eicar_test_string = "X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
    return eicar_test_string in content

# Function to count non-comment lines in a file
def raw_count(filename):
    n = 0
    with open(filename) as f:
        for line in f:
            if not line.startswith("#"):
                n = n + 1
    return n


# Function to remove malware
def remove_malware(infected_files):
    # Iterate through the list of infected files
    for file_details in infected_files:
        file_path = file_details[0]
        # Attempt to remove the infected file
        try:
            os.remove(file_path)
            print(f"Malware removed: {file_path}")
        except Exception as e:
            print(f"Error removing malware from {file_path}: {e}")
# Function to scan a directory
def scan_directory(_scan_path, progress_bar, status_text, scan_result_text):
    _log_ipaddr = get_ip_address()
    _log_hostname = platform.node()
    _log_scan_id = create_job_id()
    _log_os_ver = platform.system()

    _count_submitted_file = 0
    _count_infected_file = 0
    infected_files = []

    _scan_start_time = time.perf_counter()

    file_list = []
    for subdir, dirs, files in os.walk(_scan_path):
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        for file in files:
            file_list.append(os.path.realpath(os.path.join(subdir, file)))

    total_files = len(file_list)

    if total_files == 0:
        messagebox.showwarning("Warning", "No files found in the selected directory.")
        return

    progress_step = 100 / total_files
    progress_value = 0

    with ThreadPoolExecutor(max_workers=50) as executor:
        for _f_file_name in file_list:
            # Display the name of the file being scanned in the status_text widget
            status_text.delete(1.0, tk.END)  # Clear previous file info
            status_text.insert(tk.END, f"Scanning: {_f_file_name}\n")
            status_text.see(tk.END)

            result = executor.submit(scan_file, _f_file_name).result()
            _count_submitted_file += 1
            progress_value += progress_step
            progress_bar["value"] = progress_value
            progress_bar.update()

            if result['hash_match'] or result['string_match']:
                _count_infected_file += 1
                infected_files.append([_f_file_name, result['file_hash'], get_create_date(_f_file_name), get_modify_date(_f_file_name)])

    progress_bar["value"] = 100  # Ensure progress bar reaches 100% at the end
    progress_bar.update()

    # Display scanning details in the scan_result_text widget
    scan_result_text.insert(tk.END, f"Scan Start Time: {_scan_start_time}\n")
    scan_result_text.insert(tk.END, f"Scan ID: {_log_scan_id}\n")
    scan_result_text.insert(tk.END, f"Operating System: {_log_os_ver}\n")
    scan_result_text.insert(tk.END, f"Hostname: {_log_hostname}\n")
    scan_result_text.insert(tk.END, f"IP Address: {_log_ipaddr}\n")
    scan_result_text.insert(tk.END, f"Total Files Scanned: {total_files}\n")
    scan_result_text.insert(tk.END, f"Infected Files: {_count_infected_file}\n\n")

    # Display details of each scanned file in the scan_result_text widget
    for file_details in infected_files:
        scan_result_text.insert(tk.END, f"File: {file_details[0]}\n")
        scan_result_text.insert(tk.END, f"SHA256: {file_details[1]}\n")
        scan_result_text.insert(tk.END, f"Created At: {file_details[2]}\n")
        scan_result_text.insert(tk.END, f"Modified At: {file_details[3]}\n")
        scan_result_text.insert(tk.END, "\n")

    if _count_infected_file >= 1:
        print(f"Scan Completed!\n{_count_infected_file} files infected.")
        for file_details in infected_files:
            print(f"File: {file_details[0]}\nSHA256: {file_details[1]}\nCreated At: {file_details[2]}\nModified At: {file_details[3]}\n")
    else:
        print("Scan Completed!\nNo malware found.")

    # Prompt user to remove malware if found
    if _count_infected_file > 0:
        if messagebox.askyesno("Malware Found", "Malware detected. Do you want to remove it?"):
            remove_malware(infected_files)
            messagebox.showinfo("Malware Removed", "Malware has been removed.")
            # Update GUI or perform other actions as needed
    else:
        messagebox.showinfo("No Malware Found", "No malware found during the scan.")


# Function to handle remove malware button click
def remove_malware_button_click(scan_result_text):
    # Extract infected file details from scan results
    infected_files = []
    for line in scan_result_text.get("1.0", tk.END).split("\n"):
        if line.startswith("File: "):
            file_path = line.split(": ")[1]
            sha256 = line.split(": ")[2]
            created_at = line.split(": ")[3]
            modified_at = line.split(": ")[4]
            infected_files.append([file_path, sha256, created_at, modified_at])
    
    # Check if any infected files are present
    if infected_files:
        # Prompt user to confirm malware removal
        if messagebox.askyesno("Remove Malware", "Are you sure you want to remove all malware?"):
            # Remove malware
            remove_malware(infected_files)
            messagebox.showinfo("Malware Removed", "Malware has been successfully removed.")
            # Clear scan results text
            scan_result_text.delete("1.0", tk.END)
        else:
            messagebox.showinfo("Malware Removal Canceled", "Malware removal has been canceled.")
    else:
        messagebox.showinfo("No Malware Found", "No malware found during the scan.")



# Function to browse folder
def browse_folder():
    global folder_selected
    folder_selected.set(filedialog.askdirectory())  # Set the selected folder path to the StringVar


# Function to browse file
def browse_file():
    file_path = filedialog.askopenfilename()
    if file_path:
        global folder_selected  # Declare folder_selected as a global variable
        folder_selected = os.path.dirname(file_path)


# Function to save scan results to a file
def save_results(scan_result_text):
    # Check if scan result text is not empty
    if scan_result_text.get("1.0", tk.END).strip():
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
        if file_path:
            with open(file_path, "w") as file:
                file.write(scan_result_text.get("1.0", tk.END))
            messagebox.showinfo("Save Completed", "Scan results saved successfully!")
    else:
        messagebox.showinfo("No Results to Save", "There are no scan results to save.")


# Function to reset all GUI elements to initial state
def reset_gui(entry, progress_bar, status_text, scan_result_text):
    entry.delete(0, tk.END)
    progress_bar["value"] = 0
    status_text.delete(1.0, tk.END)
    scan_result_text.delete(1.0, tk.END)


# Main function
def main():
    global folder_selected  # Declare folder_selected as a global variable

    print(f"\n")
    print(
        f"Malware Scanner and removal tool\n"
    )

    check_engine()
    print(f"- AV Signatures   : {raw_count(_engine_extract_file_)}")


    # Define GUI
    root = tk.Tk()
    root.title("Malware Scanner")
    root.geometry("700x450")  # Set initial window size

    # Create Frames
    top_frame = tk.Frame(root)
    top_frame.pack(pady=5)

    middle_frame = tk.Frame(root)
    middle_frame.pack(pady=5)

    bottom_frame = tk.Frame(root)
    bottom_frame.pack(pady=5)

    # Create GUI Elements
    label = tk.Label(top_frame, text="Select Folder to Scan:")
    label.pack()

    folder_selected = tk.StringVar()
    entry = tk.Entry(top_frame, textvariable=folder_selected, width=50)
    entry.pack(side=tk.LEFT, padx=(0, 10))

    browse_button = tk.Button(top_frame, text="Browse", command=browse_folder)
    browse_button.pack(side=tk.LEFT)

    scan_button = tk.Button(bottom_frame, text="Scan", command=lambda: scan_directory(folder_selected.get(), progress_bar, status_text, scan_result_text))
    scan_button.pack(side=tk.TOP, pady=10)  # Pack the scan_button

    progress_bar = ttk.Progressbar(middle_frame, orient="horizontal", length=300, mode="determinate")
    progress_bar.pack(pady=10)

    status_label = tk.Label(bottom_frame, text="Scanning Status:")
    status_label.pack()

    status_text = tk.Text(bottom_frame, height=2, width=80)
    status_text.pack()

    scan_result_label = tk.Label(bottom_frame, text="Scan Results:")
    scan_result_label.pack()

    scan_result_text = tk.Text(bottom_frame, height=10, width=80)
    scan_result_text.pack()

    button_frame = tk.Frame(bottom_frame)
    button_frame.pack(side=tk.BOTTOM, pady=5)

    save_button = tk.Button(button_frame, text="Save Results", command=lambda: save_results(scan_result_text))
    save_button.pack(side=tk.LEFT, padx=5)

    remove_malware_button = tk.Button(button_frame, text="Remove Malware", command=lambda: remove_malware_button_click(scan_result_text))
    remove_malware_button.pack(side=tk.LEFT, padx=5)

    reset_button = tk.Button(button_frame, text="Reset", command=lambda: reset_gui(entry, progress_bar, status_text, scan_result_text))
    reset_button.pack(side=tk.RIGHT, padx=5)

    root.mainloop()


if __name__ == '__main__':
    main()
